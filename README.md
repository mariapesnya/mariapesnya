Сортировка выбором ( C++ ):
Алгоритм сортировки выбором работает путем последовательного выбора минимального элемента из неотсортированной части массива и обмена его с первым элементом этой части. Затем он продолжает этот процесс для оставшейся части массива, «сужая» область для поиска

В первую очередь рассматриваем весь массив, ищем минимальный элемент с индексом i=0 до конца, первый элемент - это минимальный из всех, остальные неотсортированны 
Рассматриваем массив i=1, ищем минимальный элемент со второго элемента, после меняется с элементом на позиции i=1 
Процесс продолжается для i=2, i=3 и так далее, пока не осталось всего один элемент — он уже будет на своей правильной позиции.
Временная сложность алгоритма: O(n^2) в худшем и среднем случаях

Сортивка обменом (Python):
for i in range(n): Выполняет повторный проход по массиву n раз. После каждого полного прохода самый большой из оставшихся элементов «поднимается» в конец.
for j in range(0, n - i - 1): Проходит по массиву, исключая уже отсортированные элементы с конца (i), потому что после каждого прохода последний элемент уже отсортирован и не нужен повторный сравнивать.
if arr[j] > arr[j + 1]: Если текущий элемент больше следующего — меняет их местами (операция обмена).
После выполнения всех циклов — весь массив отсортирован по возрастанию
Общая временная сложность: O(n^2) — квадратичная 

Сортировка вставками (Python):
Алгоритм сортировки вставками работает по принципу, аналогичному сортировке карт в руке:
Начинаем с первого элемента — считаем его отсортированным.
Берём следующий элемент и вставляем его в нужное место в уже отсортированной части массива.
Повторяем шаг 2 для всех оставшихся элементов.
Временная сложность: O(n^2) средний случай 

Сортировка слиянием (C++): 
Сортировка слиянием — это рекурсивный алгоритм "разделяй и властвуй":
Разделение (Divide): Массив делится пополам до тех пор, пока не останутся подмассивы из одного элемента.
Слияние (Conquer/Merge): Отсортированные подмассивы сливаются в один отсортированный массив
Используются временные массивы L[] и R[] при каждом слиянии
В худшем случае — O(n) дополнительной памяти.
Алгоритм последовательно просматривает элементы массива, сравнивая их с искомым значением.
Объяснение работы скрипта:

Последовательный (линейный) поиск — простейший вид поиска заданного элемента на
некотором множестве. Осуществляется путём последовательного сравнения очередного
рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод
является наименее эффективным, так как его временная сложность составляет O(n), где n —
количество элементов в списке. Однако он прост в реализации и может быть полезен для
небольших списков или в тех случаях, когда данные не отсортированы.
Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.

Работа скрипта:
Метод linearSearch принимает массив arr и искомое значение target.
Мы перебираем каждый элемент массива с помощью цикла for.
На каждой итерации сравниваем текущий элемент с искомым.
Если совпадение найдено, возвращаем индекс этого элемента.
Если весь массив пройден и элемент не найден, возвращаем -1.

Временная сложность: O(n)
В худшем случае потребуется пройти весь массив полностью, выполняя одну операцию сравнения за каждую итерацию, а количество итераций прямо пропорционально размеру массива.


Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на
упорядоченном множестве, осуществляемый путём неоднократного деления этого множества
на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск
заканчивается при совпадении искомого элемента с элементом, который является границей
между частями множества или при отсутствии искомого элемента. Преимуществом бинарного
поиска является более низкая трудоёмкость по сравнению с последовательным поиском.
Недостаток заключается в том, что он применим только на отсортированных множествах.

Алгоритм работает только с отсортированным массивом.
На каждом шаге область поиска уменьшается вдвое за счет сравнения с элементом в середине.

Объяснение работы скрипта:
Изначально устанавливаем границы поиска: left и right.
Пока границы не пересекаются (left <= right), выполняем цикл:
Находим средний индекс mid.
Сравниваем значение arr[mid] с искомым.
Если равно, возвращаем индекс.
Если меньше — сдвигаем левую границу вправо (left = mid + 1).
Если больше — сдвигаем правую границу влево (right = mid - 1).
Если границы пересеклись и элемент так и не найден, возвращаем -1.

Временная сложность: 
В худшем случае, при каждом шаге массив делится пополам, и в итоге за несколько шагов мы получим искомый элемент или исключим его существование.
Время выполнения: O(log n), где n — количество элементов в массиве.
Объяснение: Потому что на каждом шаге алгоритм делит массив пополам, сокращая пространство поиска вдвое. После k итераций остается проверять только один элемент. Количество таких итераций — это логарифм от размера массива, то есть log₂ n.



Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Он использует формулу интерполяции, чтобы предположить, где может находиться искомый элемент, основываясь на его предполагаемом положении относительно границ массива. В отличие от бинарного поиска, который делит массив пополам независимо от значений, интерполяционный ищет более "точечно", делая предположения, где может находиться элемент.

Работа скрипта: 
Задаем начальные границы поиска low и high.
Пока границы не пересекаются, делаем предположение о позиции pos с помощью формулы интерполяции:
[ pos = low + \frac{(target - arr[low]) \times (high - low)}{arr[high] - arr[low]} ]
Проверяем, находится ли предполагаемый индекс pos внутри границ. Если нет — возвращаем -1.
Сравниваем элемент arr[pos] с искомым:
Если равно — возвращаем индекс.
Если меньше — сдвигаем нижнюю границу вверх.
Если больше — сдвигаем верхнюю границу вниз.
Если элемент не найден — возвращаем -1.

Временная сложность:
В лучшем случае: O(log log n) — когда массив равномерно распределен и поиск максимально эффективен.
В худшем случае: O(n) — например, если массив неравномерно распределен или элементы расположены неравномерно, и предположения о позиции оказываются неверными.
Объяснение:
В идеальных условиях, когда массив равномерно распределён, формулы очень точно предсказывают позицию элемента, и поиск сужается очень быстро. В этом случае время — O(log log n).
В худшем случае, когда распределение неравномерное или предположения о позиции неверны, алгоритм может свести к линейному поиску, то есть O(n).



Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Этот алгоритм является вариацией бинарного поиска, при которой деление массива происходит по длинам, соответствующим числам Фибоначчи. Он особенно полезен, когда разделение происходит в интервалах с неравномерными размерами.

Объяснение работы скрипта:
Создаем последовательность Фибоначчи, пока число не превысит длину массива.
Используем три переменные, чтобы хранить последние два числа Фибоначчи и текущее.
В цикле сравниваем элемент, находящийся по расчетному индексу i, с искомым.
В зависимости от результата сдвигаем границы поиска, уменьшая или увеличивая диапазон, используя числа Фибоначчи.
После цикла проверяем последний возможный индекс, если он соответствует искомому.
Возвращаем индекс найденного элемента или -1, если элемент отсутствует.

Временная сложность: 
Время поиска: O(log n), аналогично бинарному поиску, так как алгоритм делит массив примерно пополам за счёт чисел Фибоначчи.
Он эффективен для больших массивов и показывает хорошие результаты на практике.
Объяснение: 
Поскольку алгоритм делит диапазон поиска по числам, связанным с последовательностью Фибоначчи, его эффективность примерно совпадает с бинарным поиском, поэтому сложность — O(log n).
