Сортировка выбором ( C++ ):
Алгоритм сортировки выбором работает путем последовательного выбора минимального элемента из неотсортированной части массива и обмена его с первым элементом этой части. Затем он продолжает этот процесс для оставшейся части массива, «сужая» область для поиска

В первую очередь рассматриваем весь массив, ищем минимальный элемент с индексом i=0 до конца, первый элемент - это минимальный из всех, остальные неотсортированны 
Рассматриваем массив i=1, ищем минимальный элемент со второго элемента, после меняется с элементом на позиции i=1 
Процесс продолжается для i=2, i=3 и так далее, пока не осталось всего один элемент — он уже будет на своей правильной позиции.
Временная сложность алгоритма: O(n^2) в худшем и среднем случаях

Сортивка обменом (Python):
for i in range(n): Выполняет повторный проход по массиву n раз. После каждого полного прохода самый большой из оставшихся элементов «поднимается» в конец.
for j in range(0, n - i - 1): Проходит по массиву, исключая уже отсортированные элементы с конца (i), потому что после каждого прохода последний элемент уже отсортирован и не нужен повторный сравнивать.
if arr[j] > arr[j + 1]: Если текущий элемент больше следующего — меняет их местами (операция обмена).
После выполнения всех циклов — весь массив отсортирован по возрастанию
Общая временная сложность: O(n^2) — квадратичная 

Сортировка вставками (Python):
Алгоритм сортировки вставками работает по принципу, аналогичному сортировке карт в руке:
Начинаем с первого элемента — считаем его отсортированным.
Берём следующий элемент и вставляем его в нужное место в уже отсортированной части массива.
Повторяем шаг 2 для всех оставшихся элементов.
Временная сложность: O(n^2) средний случай 

Сортировка слиянием (C++): 
Сортировка слиянием — это рекурсивный алгоритм "разделяй и властвуй":
Разделение (Divide): Массив делится пополам до тех пор, пока не останутся подмассивы из одного элемента.
Слияние (Conquer/Merge): Отсортированные подмассивы сливаются в один отсортированный массив
Используются временные массивы L[] и R[] при каждом слиянии
В худшем случае — O(n) дополнительной памяти.
Алгоритм последовательно просматривает элементы массива, сравнивая их с искомым значением.
Объяснение работы скрипта:

Последовательный (линейный) поиск — простейший вид поиска заданного элемента на
некотором множестве. Осуществляется путём последовательного сравнения очередного
рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод
является наименее эффективным, так как его временная сложность составляет O(n), где n —
количество элементов в списке. Однако он прост в реализации и может быть полезен для
небольших списков или в тех случаях, когда данные не отсортированы.
Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.

Работа скрипта:
Метод linearSearch принимает массив arr и искомое значение target.
Мы перебираем каждый элемент массива с помощью цикла for.
На каждой итерации сравниваем текущий элемент с искомым.
Если совпадение найдено, возвращаем индекс этого элемента.
Если весь массив пройден и элемент не найден, возвращаем -1.

Временная сложность: O(n)
В худшем случае потребуется пройти весь массив полностью, выполняя одну операцию сравнения за каждую итерацию, а количество итераций прямо пропорционально размеру массива.


