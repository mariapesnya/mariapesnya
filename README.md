Сортировка выбором ( C++ ):
Алгоритм сортировки выбором работает путем последовательного выбора минимального элемента из неотсортированной части массива и обмена его с первым элементом этой части. Затем он продолжает этот процесс для оставшейся части массива, «сужая» область для поиска

В первую очередь рассматриваем весь массив, ищем минимальный элемент с индексом i=0 до конца, первый элемент - это минимальный из всех, остальные неотсортированны 
Рассматриваем массив i=1, ищем минимальный элемент со второго элемента, после меняется с элементом на позиции i=1 
Процесс продолжается для i=2, i=3 и так далее, пока не осталось всего один элемент — он уже будет на своей правильной позиции.
Временная сложность алгоритма: O(n^2) в худшем и среднем случаях

Сортивка обменом (Python):
for i in range(n): Выполняет повторный проход по массиву n раз. После каждого полного прохода самый большой из оставшихся элементов «поднимается» в конец.
for j in range(0, n - i - 1): Проходит по массиву, исключая уже отсортированные элементы с конца (i), потому что после каждого прохода последний элемент уже отсортирован и не нужен повторный сравнивать.
if arr[j] > arr[j + 1]: Если текущий элемент больше следующего — меняет их местами (операция обмена).
После выполнения всех циклов — весь массив отсортирован по возрастанию
Общая временная сложность: O(n^2) — квадратичная 

Сортировка вставками (Python):
Алгоритм сортировки вставками работает по принципу, аналогичному сортировке карт в руке:
Начинаем с первого элемента — считаем его отсортированным.
Берём следующий элемент и вставляем его в нужное место в уже отсортированной части массива.
Повторяем шаг 2 для всех оставшихся элементов.
Временная сложность: O(n^2) средний случай 

Сортировка слиянием (C++): 
Сортировка слиянием — это рекурсивный алгоритм "разделяй и властвуй":
Разделение (Divide): Массив делится пополам до тех пор, пока не останутся подмассивы из одного элемента.
Слияние (Conquer/Merge): Отсортированные подмассивы сливаются в один отсортированный массив
Используются временные массивы L[] и R[] при каждом слиянии
В худшем случае — O(n) дополнительной памяти.
